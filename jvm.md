# 课时2

- JIT 即时编译期
- 部分代码进行即时编译
- 热点代码
- 检测方式
- 方法调用计数器 超过阈值，就jit 然后调用缓存。
- client 端是 1500， server是10000。 jvm 参数可以调整。
- client跟server端是根据服务器的环境决定是否client 或者server
- jvm 可以运行 Python之类编译的class

# 课时3

- class结构规范
- 前四个字节是固定的。魔数
- 4个字节标识版本号，主副版本号
- javap
- 0 副版本号
- 52 jdk 8
- 常量池计数器/常量池数据区 （计数器标记池的长度） cp_info（非运行时，这里是静态信息，运行时动态加载这些信息到运行时常量池）
- 字面量、符号引用
- 访问标志 （public、final、class、interface） 
- 类、父类索引
- 接口计数器、接口信息
- 字段、方法、属性的计数器和数据区
- pc寄存器，记录代码位置（偏移量）

# 课时4

- jni 本地方法接口
- pc 寄存器 栈区 本地方法栈 一个线程一个
- 运行时数据区 包含 pc寄存器 本地方法栈 方法区 堆区 栈区
- 堆区 方法区是内存共享的。这两个地方进行垃圾回收， 上面线程的，不会进行垃圾回收。
- 堆 分 新生代(1/3)、老年代(2/3)
- 新生代 分 伊甸园区 eden 8/10 from to（幸存区） 各 1/10
- 代由垃圾回收算法决定
- Perm 是永久代 1.7后没有了 (是内存区域，但不是heap中，jvm中的内存)
- eden -Xmn
- minor GC --young
- major GC --old
- full GC
- perm -> meta （已经不属于jvm 的内存区域，但是是机器的内存） 存方法
- 栈帧 -》 方法
- 栈 后入先出
- 包含局部变量表 、 操作栈、 动态链接、返回地址等等。
- 局部变量 如果值是基本类型，就存在栈中，如果是其他类型，值存在堆中，返回一个地址给栈记录地址。
- 引用变量间的赋值，只是地址的赋值
- 对象分配内存（伊甸园区） 指针碰撞、空闲列表的分配方式
- 对象头有偏向锁、年龄15 轮转入老年代
- 分配原则。空间不足就用minorgc
- 分配原则。大对象创建直接存入老年代
- 多个小块区域均不足创建一个对象时，就执行gc
- 内存分配也是gc相关的
- 线程内存分配的安全问题 cas（+失败重试 实现原子性）、tlab（预先分配一块给各自线程，不足了就用cas）
- 对象访问（句柄池，直接指针）
- 句柄池也在堆里面。栈里面的本地变量表，如果有非基本类型，必然是引用的。首先引用的是句柄，非默认方式
- 句柄包含类型指针（指向方法区（元空间）的class定义地址）、实例指针（指向堆空间的一块区域），非默认方式
- 直接指针 对象实例的对象头包含了类型指针， hotspot 默认使用这个方式访问，速度快

# 课时5

- 操作数栈入栈 a = 1 iconst_1
- 栈顶元素移入本地变量表存储 a = 1 istore_1 ，没有运算，直接放入
- iload 局部变量表 -》 操作数栈
- 运算需要操作操作数栈
- iadd pop 两个栈顶元素， 然后结果压入栈顶
- return 之前需要istore一下
- class常量池、运行时常量池、字符串常量池
- 字符串常量池 ， 可以节省空间、== 可以比较引用 比较快、执行性能好。
- class常量池就是class文件的一部分，在version后面。
- cp_info 常量池项
cp_info {
    u1 tag; //一个字节 的类型 
    u1 info[];
}
- 类常量池项是引用（符号引用，不是指值，比如类是限定名，表示字段类型）。其他是字面量。
- JVM在装载class文件的时候，会有一步是将符号引用解析为直接引用的过程。 意思是将类限定名（class_info存储的是class_index，指向utf8_info），转为方法区内该类定义的地址
- class常量池里面，相同的值只存一份
- long型double型存放高4位，低4位
- string 用 CONSTANT_string_info 记录，string_index指向utf8_info在常量池中的下标
- 所有默认值的类定义都要写入常量池中
- 在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代
- 在JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代
- 在JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace) 
- 简单来说就是intern用来返回常量池中的某字符串，如果常量池中已经存在该字符串，则直接返回常量池中该对象的引用